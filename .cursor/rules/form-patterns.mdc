---
description: Guidelines for implementing forms with pure Next.js, React hooks, and API integration
---

# Form Implementation Patterns (Pure Next.js)

## Overview

Forms in Sangue Solidário use **pure React hooks** and **Next.js form patterns** without external form libraries. All forms integrate with the structured API service that returns `IAPIResponse` types.

## Form Architecture

### Directory Structure

```
src/features/[FeatureName]/
├── components/
│   └── [FormName]Form/
│       ├── index.tsx           # Main form component
│       ├── styles.module.scss  # Form styles
│       └── validation.ts       # Custom validation logic
├── interfaces/
│   └── [feature].interface.ts  # Form data interfaces
└── services/
    └── [feature].service.ts    # API service methods
```

## Basic Form Pattern

### Client Component Form with Controlled Inputs

```typescript
"use client";

import { useState, FormEvent, ChangeEvent } from "react";
import { isAPISuccess } from "@/service/api/api";
import styles from "./styles.module.scss";
import contactService from "../../services/contact.service";

export interface IContactFormData {
  name: string;
  email: string;
  subject: string;
  message: string;
}

interface IFormErrors {
  name?: string;
  email?: string;
  subject?: string;
  message?: string;
}

export const ContactForm = () => {
  const [formData, setFormData] = useState<IContactFormData>({
    name: "",
    email: "",
    subject: "",
    message: "",
  });

  const [errors, setErrors] = useState<IFormErrors>({});
  const [touched, setTouched] = useState<
    Record<keyof IContactFormData, boolean>
  >({
    name: false,
    email: false,
    subject: false,
    message: false,
  });

  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitStatus, setSubmitStatus] = useState<{
    type: "success" | "error" | null;
    message: string;
  }>({ type: null, message: "" });

  // Validation function
  const validate = (
    name: keyof IContactFormData,
    value: string
  ): string | undefined => {
    switch (name) {
      case "name":
        if (!value.trim()) return "Nome é obrigatório";
        if (value.length < 3) return "Nome deve ter pelo menos 3 caracteres";
        if (value.length > 100) return "Nome deve ter no máximo 100 caracteres";
        break;

      case "email":
        if (!value.trim()) return "E-mail é obrigatório";
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(value)) return "E-mail inválido";
        break;

      case "subject":
        if (!value.trim()) return "Assunto é obrigatório";
        if (value.length < 5) return "Assunto deve ter pelo menos 5 caracteres";
        if (value.length > 200)
          return "Assunto deve ter no máximo 200 caracteres";
        break;

      case "message":
        if (!value.trim()) return "Mensagem é obrigatória";
        if (value.length < 10)
          return "Mensagem deve ter pelo menos 10 caracteres";
        if (value.length > 1000)
          return "Mensagem deve ter no máximo 1000 caracteres";
        break;
    }
  };

  // Validate all fields
  const validateAll = (): boolean => {
    const newErrors: IFormErrors = {};
    let isValid = true;

    (Object.keys(formData) as Array<keyof IContactFormData>).forEach((key) => {
      const error = validate(key, formData[key]);
      if (error) {
        newErrors[key] = error;
        isValid = false;
      }
    });

    setErrors(newErrors);
    return isValid;
  };

  // Handle input change
  const handleChange = (
    e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));

    // Clear error when user starts typing
    if (errors[name as keyof IFormErrors]) {
      setErrors((prev) => ({ ...prev, [name]: undefined }));
    }
  };

  // Handle blur for validation
  const handleBlur = (
    e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value } = e.target;
    setTouched((prev) => ({ ...prev, [name]: true }));

    const error = validate(name as keyof IContactFormData, value);
    setErrors((prev) => ({ ...prev, [name]: error }));
  };

  // Handle form submission
  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    // Mark all fields as touched
    setTouched({
      name: true,
      email: true,
      subject: true,
      message: true,
    });

    // Validate all fields
    if (!validateAll()) {
      setSubmitStatus({
        type: "error",
        message: "Por favor, corrija os erros antes de enviar",
      });
      return;
    }

    setIsSubmitting(true);
    setSubmitStatus({ type: null, message: "" });

    try {
      const response = await contactService.registerContact(formData);

      if (isAPISuccess(response)) {
        setSubmitStatus({
          type: "success",
          message: response.message || "Mensagem enviada com sucesso!",
        });

        // Reset form
        setFormData({
          name: "",
          email: "",
          subject: "",
          message: "",
        });
        setTouched({
          name: false,
          email: false,
          subject: false,
          message: false,
        });
        setErrors({});
      } else {
        setSubmitStatus({
          type: "error",
          message: response.message || "Erro ao enviar mensagem",
        });
      }
    } catch (error) {
      setSubmitStatus({
        type: "error",
        message: "Erro inesperado. Tente novamente.",
      });
      console.error("Form submission error:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className={styles.formContainer}>
      <form className={styles.form} onSubmit={handleSubmit} noValidate>
        <div className={styles.formGroup}>
          <label htmlFor="name" className={styles.label}>
            Nome completo <span className={styles.required}>*</span>
          </label>
          <input
            type="text"
            id="name"
            name="name"
            value={formData.name}
            onChange={handleChange}
            onBlur={handleBlur}
            className={`${styles.input} ${
              errors.name && touched.name ? styles.inputError : ""
            }`}
            placeholder="Digite seu nome"
            aria-invalid={errors.name && touched.name ? "true" : "false"}
            aria-describedby={errors.name ? "name-error" : undefined}
          />
          {errors.name && touched.name && (
            <span id="name-error" className={styles.error} role="alert">
              {errors.name}
            </span>
          )}
        </div>

        <div className={styles.formGroup}>
          <label htmlFor="email" className={styles.label}>
            E-mail <span className={styles.required}>*</span>
          </label>
          <input
            type="email"
            id="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            onBlur={handleBlur}
            className={`${styles.input} ${
              errors.email && touched.email ? styles.inputError : ""
            }`}
            placeholder="seu@email.com"
            aria-invalid={errors.email && touched.email ? "true" : "false"}
            aria-describedby={errors.email ? "email-error" : undefined}
          />
          {errors.email && touched.email && (
            <span id="email-error" className={styles.error} role="alert">
              {errors.email}
            </span>
          )}
        </div>

        <div className={styles.formGroup}>
          <label htmlFor="subject" className={styles.label}>
            Assunto <span className={styles.required}>*</span>
          </label>
          <input
            type="text"
            id="subject"
            name="subject"
            value={formData.subject}
            onChange={handleChange}
            onBlur={handleBlur}
            className={`${styles.input} ${
              errors.subject && touched.subject ? styles.inputError : ""
            }`}
            placeholder="Qual o assunto?"
            aria-invalid={errors.subject && touched.subject ? "true" : "false"}
            aria-describedby={errors.subject ? "subject-error" : undefined}
          />
          {errors.subject && touched.subject && (
            <span id="subject-error" className={styles.error} role="alert">
              {errors.subject}
            </span>
          )}
        </div>

        <div className={styles.formGroup}>
          <label htmlFor="message" className={styles.label}>
            Mensagem <span className={styles.required}>*</span>
          </label>
          <textarea
            id="message"
            name="message"
            value={formData.message}
            onChange={handleChange}
            onBlur={handleBlur}
            rows={5}
            className={`${styles.input} ${styles.textarea} ${
              errors.message && touched.message ? styles.inputError : ""
            }`}
            placeholder="Digite sua mensagem"
            aria-invalid={errors.message && touched.message ? "true" : "false"}
            aria-describedby={errors.message ? "message-error" : undefined}
          />
          {errors.message && touched.message && (
            <span id="message-error" className={styles.error} role="alert">
              {errors.message}
            </span>
          )}
        </div>

        {submitStatus.type && (
          <div
            className={`${styles.alert} ${
              submitStatus.type === "success"
                ? styles.alertSuccess
                : styles.alertError
            }`}
            role="alert"
          >
            {submitStatus.message}
          </div>
        )}

        <button
          type="submit"
          disabled={isSubmitting}
          className={styles.submitButton}
          aria-busy={isSubmitting}
        >
          {isSubmitting ? "Enviando..." : "Enviar mensagem"}
        </button>
      </form>
    </div>
  );
};
```

## Validation Utilities

### Reusable Validation Functions

```typescript
// src/utils/validation.ts

/**
 * Validate email format
 */
export const validateEmail = (email: string): string | undefined => {
  if (!email.trim()) return "E-mail é obrigatório";
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) return "E-mail inválido";
};

/**
 * Validate CPF format (Brazilian document)
 */
export const validateCPF = (cpf: string): string | undefined => {
  if (!cpf.trim()) return "CPF é obrigatório";
  const cpfRegex = /^\d{3}\.\d{3}\.\d{3}-\d{2}$/;
  if (!cpfRegex.test(cpf)) return "CPF inválido (formato: 000.000.000-00)";

  // Add CPF validation logic here
  const numbers = cpf.replace(/\D/g, "");
  if (numbers.length !== 11) return "CPF deve ter 11 dígitos";

  // Check if all digits are the same
  if (/^(\d)\1+$/.test(numbers)) return "CPF inválido";

  return undefined;
};

/**
 * Validate CNPJ format (Brazilian company document)
 */
export const validateCNPJ = (cnpj: string): string | undefined => {
  if (!cnpj.trim()) return "CNPJ é obrigatório";
  const cnpjRegex = /^\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2}$/;
  if (!cnpjRegex.test(cnpj))
    return "CNPJ inválido (formato: 00.000.000/0000-00)";
};

/**
 * Validate phone number
 */
export const validatePhone = (phone: string): string | undefined => {
  if (!phone.trim()) return "Telefone é obrigatório";
  const phoneRegex = /^\(\d{2}\) \d{4,5}-\d{4}$/;
  if (!phoneRegex.test(phone))
    return "Telefone inválido (formato: (00) 00000-0000)";
};

/**
 * Validate CEP (Brazilian zip code)
 */
export const validateCEP = (cep: string): string | undefined => {
  if (!cep.trim()) return "CEP é obrigatório";
  const cepRegex = /^\d{5}-\d{3}$/;
  if (!cepRegex.test(cep)) return "CEP inválido (formato: 00000-000)";
};

/**
 * Validate password strength
 */
export const validatePassword = (password: string): string | undefined => {
  if (!password) return "Senha é obrigatória";
  if (password.length < 8) return "Senha deve ter pelo menos 8 caracteres";
  if (!/[a-z]/.test(password)) return "Senha deve conter letra minúscula";
  if (!/[A-Z]/.test(password)) return "Senha deve conter letra maiúscula";
  if (!/[0-9]/.test(password)) return "Senha deve conter número";
  if (!/[!@#$%^&*]/.test(password))
    return "Senha deve conter caractere especial (!@#$%^&*)";
};

/**
 * Validate password confirmation
 */
export const validatePasswordConfirmation = (
  password: string,
  confirmation: string
): string | undefined => {
  if (!confirmation) return "Confirmação de senha é obrigatória";
  if (password !== confirmation) return "Senhas não conferem";
};

/**
 * Validate date (not in future)
 */
export const validateDate = (date: string): string | undefined => {
  if (!date) return "Data é obrigatória";
  const selectedDate = new Date(date);
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  if (selectedDate > today) return "Data não pode ser futura";
};

/**
 * Validate required field
 */
export const validateRequired = (
  value: string,
  fieldName: string
): string | undefined => {
  if (!value.trim()) return `${fieldName} é obrigatório`;
};

/**
 * Validate min length
 */
export const validateMinLength = (
  value: string,
  min: number,
  fieldName: string
): string | undefined => {
  if (value.length < min)
    return `${fieldName} deve ter pelo menos ${min} caracteres`;
};

/**
 * Validate max length
 */
export const validateMaxLength = (
  value: string,
  max: number,
  fieldName: string
): string | undefined => {
  if (value.length > max)
    return `${fieldName} deve ter no máximo ${max} caracteres`;
};

/**
 * Validate blood type
 */
export const validateBloodType = (bloodType: string): string | undefined => {
  if (!bloodType) return "Tipo sanguíneo é obrigatório";
  const validTypes = ["A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-"];
  if (!validTypes.includes(bloodType)) return "Tipo sanguíneo inválido";
};

/**
 * Validate file size
 */
export const validateFileSize = (
  file: File,
  maxSizeMB: number
): string | undefined => {
  const maxSizeBytes = maxSizeMB * 1024 * 1024;
  if (file.size > maxSizeBytes)
    return `Arquivo muito grande (máximo ${maxSizeMB}MB)`;
};

/**
 * Validate file type
 */
export const validateFileType = (
  file: File,
  allowedTypes: string[]
): string | undefined => {
  if (!allowedTypes.includes(file.type)) {
    return `Formato não permitido. Use: ${allowedTypes.join(", ")}`;
  }
};
```

## Custom Hook for Forms

### useForm Hook

```typescript
// src/hooks/useForm.ts
import { useState, ChangeEvent, FormEvent } from "react";

interface UseFormOptions<T> {
  initialValues: T;
  validate: (name: keyof T, value: any) => string | undefined;
  onSubmit: (values: T) => Promise<void>;
}

export function useForm<T extends Record<string, any>>({
  initialValues,
  validate,
  onSubmit,
}: UseFormOptions<T>) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = (
    e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    setValues((prev) => ({ ...prev, [name]: value }));

    // Clear error when user starts typing
    if (errors[name as keyof T]) {
      setErrors((prev) => ({ ...prev, [name]: undefined }));
    }
  };

  const handleBlur = (
    e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    setTouched((prev) => ({ ...prev, [name]: true }));

    const error = validate(name as keyof T, value);
    setErrors((prev) => ({ ...prev, [name]: error }));
  };

  const validateAll = (): boolean => {
    const newErrors: Partial<Record<keyof T, string>> = {};
    let isValid = true;

    (Object.keys(values) as Array<keyof T>).forEach((key) => {
      const error = validate(key, values[key]);
      if (error) {
        newErrors[key] = error;
        isValid = false;
      }
    });

    setErrors(newErrors);
    return isValid;
  };

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    // Mark all fields as touched
    const allTouched = Object.keys(values).reduce(
      (acc, key) => ({ ...acc, [key]: true }),
      {}
    );
    setTouched(allTouched);

    // Validate all fields
    if (!validateAll()) {
      return;
    }

    setIsSubmitting(true);
    try {
      await onSubmit(values);
    } finally {
      setIsSubmitting(false);
    }
  };

  const resetForm = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    setValues,
    setErrors,
  };
}
```

### Using the useForm Hook

```typescript
"use client";

import { useForm } from "@/hooks/useForm";
import { isAPISuccess } from "@/service/api/api";
import { validateEmail, validateRequired } from "@/utils/validation";
import contactService from "../../services/contact.service";
import styles from "./styles.module.scss";

interface IContactFormData {
  name: string;
  email: string;
  message: string;
}

export const ContactFormWithHook = () => {
  const validate = (name: keyof IContactFormData, value: string) => {
    switch (name) {
      case "name":
        return validateRequired(value, "Nome");
      case "email":
        return validateEmail(value);
      case "message":
        return validateRequired(value, "Mensagem");
    }
  };

  const handleFormSubmit = async (values: IContactFormData) => {
    const response = await contactService.registerContact(values);

    if (isAPISuccess(response)) {
      alert(response.message);
      resetForm();
    } else {
      alert(response.message);
    }
  };

  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
  } = useForm<IContactFormData>({
    initialValues: { name: "", email: "", message: "" },
    validate,
    onSubmit: handleFormSubmit,
  });

  return (
    <form onSubmit={handleSubmit} className={styles.form}>
      <div className={styles.formGroup}>
        <label htmlFor="name">Nome</label>
        <input
          type="text"
          id="name"
          name="name"
          value={values.name}
          onChange={handleChange}
          onBlur={handleBlur}
          className={errors.name && touched.name ? styles.inputError : ""}
        />
        {errors.name && touched.name && (
          <span className={styles.error}>{errors.name}</span>
        )}
      </div>

      <div className={styles.formGroup}>
        <label htmlFor="email">E-mail</label>
        <input
          type="email"
          id="email"
          name="email"
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
          className={errors.email && touched.email ? styles.inputError : ""}
        />
        {errors.email && touched.email && (
          <span className={styles.error}>{errors.email}</span>
        )}
      </div>

      <div className={styles.formGroup}>
        <label htmlFor="message">Mensagem</label>
        <textarea
          id="message"
          name="message"
          value={values.message}
          onChange={handleChange}
          onBlur={handleBlur}
          className={errors.message && touched.message ? styles.inputError : ""}
        />
        {errors.message && touched.message && (
          <span className={styles.error}>{errors.message}</span>
        )}
      </div>

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Enviando..." : "Enviar"}
      </button>
    </form>
  );
};
```

## Form Styling

### SCSS Module for Forms

```scss
// styles.module.scss
.formContainer {
  max-width: 600px;
  margin: 0 auto;
  padding: 2rem;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.formGroup {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.label {
  font-weight: 600;
  font-size: 0.9rem;
  color: #333;
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.required {
  color: #dc3545;
}

.input {
  padding: 0.75rem 1rem;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  font-size: 1rem;
  transition: all 0.3s ease;
  font-family: inherit;

  &:focus {
    outline: none;
    border-color: #e63946;
    box-shadow: 0 0 0 3px rgba(230, 57, 70, 0.1);
  }

  &.inputError {
    border-color: #dc3545;

    &:focus {
      box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.1);
    }
  }

  &::placeholder {
    color: #999;
  }
}

.textarea {
  resize: vertical;
  min-height: 120px;
}

.error {
  color: #dc3545;
  font-size: 0.85rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;

  &::before {
    content: "⚠";
  }
}

.alert {
  padding: 1rem;
  border-radius: 8px;
  font-size: 0.9rem;
  text-align: center;
  animation: slideIn 0.3s ease;

  &.alertSuccess {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
  }

  &.alertError {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
  }
}

.submitButton {
  padding: 1rem 2rem;
  background-color: #e63946;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;

  &:hover:not(:disabled) {
    background-color: #d62839;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(230, 57, 70, 0.3);
  }

  &:active:not(:disabled) {
    transform: translateY(0);
  }

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

// Responsive
@media (max-width: 768px) {
  .formContainer {
    padding: 1rem;
  }

  .input,
  .submitButton {
    font-size: 0.9rem;
  }
}
```

## Best Practices

### 1. Always Use Client Components for Interactive Forms

```typescript
"use client"; // Required for forms with state

import { useState } from "react";
// ... rest of component
```

### 2. Implement Proper Validation

```typescript
// ✅ Good - Validate on blur and before submit
const handleBlur = (e) => {
  const error = validate(e.target.name, e.target.value);
  setErrors((prev) => ({ ...prev, [e.target.name]: error }));
};

// ❌ Bad - No validation
const handleChange = (e) => {
  setFormData((prev) => ({ ...prev, [e.target.name]: e.target.value }));
};
```

### 3. Handle API Responses with Type Guards

```typescript
// ✅ Good
const response = await service.submitForm(formData);
if (isAPISuccess(response)) {
  // Handle success
} else {
  // Handle error
}

// ❌ Bad
const data = await service.submitForm(formData);
// Assumes success
```

### 4. Provide Accessibility

```typescript
// ✅ Good - Full accessibility
<input
  aria-invalid={errors.email && touched.email ? "true" : "false"}
  aria-describedby={errors.email ? "email-error" : undefined}
/>;
{
  errors.email && touched.email && (
    <span id="email-error" role="alert">
      {errors.email}
    </span>
  );
}

// ❌ Bad - No accessibility
<input />;
{
  errors.email && <span>{errors.email}</span>;
}
```

### 5. Show Loading States

```typescript
// ✅ Good
<button type="submit" disabled={isSubmitting} aria-busy={isSubmitting}>
  {isSubmitting ? "Enviando..." : "Enviar"}
</button>

// ❌ Bad
<button type="submit">Enviar</button>
```

### 6. Use TypeScript Interfaces

```typescript
// ✅ Good
interface IFormData {
  name: string;
  email: string;
}

const [formData, setFormData] = useState<IFormData>({
  name: "",
  email: "",
});

// ❌ Bad
const [formData, setFormData] = useState({
  name: "",
  email: "",
});
```

### 7. Clear Errors on Input

```typescript
// ✅ Good
const handleChange = (e) => {
  setFormData((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  if (errors[e.target.name]) {
    setErrors((prev) => ({ ...prev, [e.target.name]: undefined }));
  }
};
```

## Common Pitfalls

1. ❌ **Forgetting "use client" directive** - Forms need client-side interactivity
2. ❌ **Not validating before submit** - Always validate all fields
3. ❌ **Mutating state directly** - Use setState functions
4. ❌ **Ignoring accessibility** - Add proper ARIA attributes
5. ❌ **Not handling loading states** - Show feedback during submission
6. ❌ **Skipping error handling** - Always handle API errors
7. ❌ **Not typing form data** - Use TypeScript interfaces
8. ❌ **Forgetting to reset form** - Clear form after successful submission
